%{
#include <stdio.h>
#include <util.h>
#include <assert.h>

#include "amd64.h"
#include "ht.h"
#include "op.h"

#define BUNDLE_MASK_16 "0xfffffff0"
#define BUNDLE_MASK_32 "0xffffffe0"

#define BUNDLE_P2 "5"
#define BUNDLE_MASK BUNDLE_MASK_16

extern FILE* input;
extern FILE* output;

typedef struct transform {
    char* val;
    char* valrdi;
    char** guard;
    size_t n_guard;
    char** guardrdi;
    size_t n_guardrdi;
    char* post;
} Transform;

static char*
strclean(char* s, size_t n)
{
    char* sdup = strndup(s, n);
    for (size_t i = 0; i < n; i++) {
        if (sdup[i] == ';' || sdup[i] == '\n' || sdup[i] == '\r')
            sdup[i] = ' ';
    }
    return sdup;
}

static void
tfree(Transform t)
{
    free(t.val);
    for (size_t i = 0; i < t.n_guard; i++)
        free(t.guard[i]);
    for (size_t i = 0; i < t.n_guardrdi; i++)
        free(t.guardrdi[i]);
    free(t.guard);
    free(t.guardrdi);
    free(t.post);
}

static char*
l(char* op)
{
    size_t len = strlen(op);
    char* ret = strdup(op);
    if (op[len - 1] == 'q')
        ret[len - 1] = 'l';
    return ret;
}

// returns true if guardrdi used
static bool
mkguards_(Transform t, bool h)
{
    char** guard = t.guard;
    size_t n_guard = t.n_guard;
    if (t.n_guardrdi > 0 && h) {
        guard = t.guardrdi;
        n_guard = t.n_guardrdi;
    }
    for (size_t i = 0; i < n_guard; i++) {
        if (guard[i][0] == '.')
            mkdirective(guard[i]);
        else
            mkinsn("%s\n", guard[i]);
    }
    return t.n_guardrdi > 0;
}

static bool
mkguardsh(Transform t)
{
    return mkguards_(t, true);
}

static void
mkguards(Transform t)
{
    mkguards_(t, false);
}

static void
setguard(Transform* t, size_t n, char** x)
{
    t->guard = malloc(n * sizeof(char*));
    memcpy(t->guard, x, n * sizeof(char*));
    t->n_guard = n;
}

static void
setguardrdi(Transform* t, size_t n, char** x)
{
    t->guardrdi = malloc(n * sizeof(char*));
    memcpy(t->guardrdi, x, n * sizeof(char*));
    t->n_guardrdi = n;
}

#define YYSTYPE Transform

#define YY_INPUT(buf, result, max_size)      \
{                                            \
    result = fread(buf, 1, max_size, input); \
}                                            \
%}

Top = Insn* !.

Insn = INDENT Label? (
      FnDirective
    | Directive
    | Leave
    | ModLeaSP
    | Lea
    | Stos
    | Movs
    | ModSP
    | Triple0
    | Triple1
    | Triple2
    | StoreH
    | Store
    | LoadH
    | Load
    | Access
    | Branch
    | BranchMem
    | BranchMemSafe
    | CallInd
    | CallIndMem
    | CallIndMemSafe
    | Call
    | Ret
    | Syscall
    | COMMENT
    | AnyInsnPrefix
    | AnyInsn
    | Any
) - COMMENT? (EOL | ';')+

COMMENT = ((('//' | '#') (!EOL .)*) | ('/*' (!'*/' .)* '*/'))

INDENT = < [ \t]* > {
    // if (yyleng > 0)
        // printf("%s", yytext);
}

REMAINDER = < (!(EOL | ';') .)* > { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

PREFIX = < ('lock' | 'rep' | 'rex64' | 'rex') > [ \t\r\n;]+ {
    $$ = (Transform) { .val = strndup(yytext, yyleng) }
}

AnyInsnPrefix = p:PREFIX rest:REMAINDER {
    mkinsn("%s %s\n", p.val, rest.val);
}

AnyInsn = rest:REMAINDER {
    mkinsn("%s\n", rest.val);
}

# --- loads and stores ---

Stos = s:STOS rest:REMAINDER {
    mkcodedirective(".bundle_lock\n");
    mkinsn("movl %%edi, %%edi\n");
    mkinsn("leaq (%%r14, %%rdi), %%rdi\n");
    mkinsn("%s %s\n", s.val, rest.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(s);
}

STOS = < ('rep' [ \t\r\n;]+)? 'stos' [qlb] - > {
    $$ = (Transform) { .val = strclean(yytext, yyleng) }
}

Movs = m:MOVS (LP | &(EOL | ';')) (!(EOL | ';') .)* {
    mkcodedirective(".bundle_lock\n");
    mkinsn("movl %%edi, %%edi\n");
    mkinsn("leaq (%%r14, %%rdi), %%rdi\n");
    mkinsn("movl %%esi, %%esi\n");
    mkinsn("leaq (%%r14, %%rsi), %%rsi\n");
    mkinsn("%s\n", m.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(m);
}

MOVS = < ('rep' [ \t\r\n;]+)? 'movs' [qlb] - > {
    $$ = (Transform) { .val = strclean(yytext, yyleng) }
}

Lea = l:LEA a:AddrNoMod COMMA r:REG {
    mkinsn("%s %s, %s\n", l.val, a.val, r.val);
    tfree(l); tfree(a); tfree(r);
}

LEA = < ('lea' [wlq]?) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

Access = m:NAME a:Addr {
    mkguards(a);
    mkinsn("%s %s\n", m.val, a.val);
    mkcodedirective(".bundle_unlock\n");
}

LoadH = m:NAME a:Addr COMMA r:HREG {
    if (!mkguardsh(a)) {
        mkinsn("%s %s, %s\n", m.val, a.val, r.val);
        mkcodedirective(".bundle_unlock\n");
    } else {
        mkinsn("%s %s, %s\n", m.val, a.valrdi, r.val);
        mkinsn("%s\n", a.post);
        mkcodedirective(".bundle_unlock\n");
    }
    tfree(m); tfree(a); tfree(r);
}

Load = m:NAME a:Addr COMMA r:ITEM {
    mkguards(a);
    mkinsn("%s %s, %s\n", m.val, a.val, r.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(m); tfree(a); tfree(r);
}

StoreH = m:NAME r:HREG COMMA a:Addr {
    if (!mkguardsh(a)) {
        mkinsn("%s %s, %s\n", m.val, r.val, a.val);
        mkcodedirective(".bundle_unlock\n");
    } else {
        mkinsn("%s %s, %s\n", m.val, r.val, a.valrdi);
        mkinsn("%s\n", a.post);
        mkcodedirective(".bundle_unlock\n");
    }
    tfree(m); tfree(a); tfree(r);
}

Store = m:NAME r:ITEM COMMA a:Addr {
    mkguards(a);
    mkinsn("%s %s, %s\n", m.val, r.val, a.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(m); tfree(a); tfree(r);
}

Triple0 = m:NAME a:Addr COMMA r1:ITEM COMMA r2:ITEM {
    mkguards(a);
    mkinsn("%s %s, %s, %s\n", m.val, a.val, r1.val, r2.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(m); tfree(a); tfree(r1); tfree(r2);
}

Triple1 = m:NAME r1:ITEM COMMA a:Addr COMMA r2:ITEM {
    mkguards(a);
    mkinsn("%s %s, %s, %s\n", m.val, r1.val, a.val, r2.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(m); tfree(a); tfree(r1); tfree(r2);
}

Triple2 = m:NAME r1:ITEM COMMA r2:ITEM COMMA a:Addr {
    mkguards(a);
    mkinsn("%s %s, %s, %s\n", m.val, a.val, r1.val, r2.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(m); tfree(a); tfree(r1); tfree(r2);
}

Addr = (
    # (%rxx)
      (LP r:XREG_NOSP RP) {
        $$ = (Transform) {
            .val = xasprintf("(%%r14, %%r15)", r.val),
            .valrdi = strdup("(%rdi)"),
            .post = strdup("movq %r15, %rdi"),
        };
        setguard(&$$, 2, (char*[]) {
            strdup(".bundle_lock\n"),
            xasprintf("movl %s, %%r15d", lo(r.val))
        });
        setguardrdi(&$$, 5, (char*[]){
            strdup("movq %rdi, %r15"),
            xasprintf("leaq (%s), %%rdi", r.val),
            strdup(".bundle_lock\n"),
            strdup("movl %edi, %edi"),
            strdup("orq %r14, %rdi"),
        });
    }
    # imm(%rxx)
    | (i:IMM LP r:XREG_NOSP RP) {
        $$ = (Transform) {
            .val = xasprintf("%s(%%r14, %%r15)", i.val, r.val),
            .valrdi = strdup("(%rdi)"),
            .post = strdup("movq %r15, %rdi"),
        };
        setguard(&$$, 2, (char*[]) {
            strdup(".bundle_lock\n"),
            xasprintf("movl %s, %%r15d", lo(r.val))
        });
        setguardrdi(&$$, 5, (char*[]){
            strdup("movq %rdi, %r15"),
            xasprintf("leaq %s(%s), %%rdi", i.val, r.val),
            strdup(".bundle_lock\n"),
            strdup("movl %edi, %edi"),
            strdup("orq %r14, %rdi"),
        });
    }
    # imm(...)
    | (i:IMM b:AddrRegDisp) {
        $$ = (Transform) {
            .val = xasprintf("(%%r14, %%r15)"),
            .valrdi = xasprintf("(%%rdi)"),
            .post = strdup("movq %r15, %rdi"),
        };
        setguard(&$$, 3, (char*[]) {
            xasprintf("leaq %s%s, %%r15", i.val, b.val),
            strdup(".bundle_lock\n"),
            xasprintf("movl %%r15d, %%r15d"),
        });
        setguardrdi(&$$, 5, (char*[]){
            strdup("movq %rdi, %r15"),
            xasprintf("leaq %s%s, %%rdi", i.val, b.val),
            strdup(".bundle_lock\n"),
            strdup("movl %edi, %edi"),
            strdup("orq %r14, %rdi"),
        });
    }
    # (...)
    | (b:AddrRegDisp) {
        $$ = (Transform) {
            .val = xasprintf("(%%r14, %%r15)"),
            .valrdi = xasprintf("(%%rdi)"),
            .post = strdup("movq %r15, %rdi"),
        };
        setguard(&$$, 3, (char*[]) {
            xasprintf("leaq %s, %%r15", b.val),
            strdup(".bundle_lock\n"),
            xasprintf("movl %%r15d, %%r15d"),
        });
        setguardrdi(&$$, 5, (char*[]){
            strdup("movq %rdi, %r15"),
            xasprintf("leaq %s, %%rdi", b.val),
            strdup(".bundle_lock\n"),
            strdup("movl %edi, %edi"),
            strdup("orq %r14, %rdi"),
        });
    }
    # imm
    | (n:NUM &(- (EOL | ';' | ','))) {
        $$ = (Transform) {
            .val = xasprintf("%s(%%r14)", n.val)
        };
        setguard(&$$, 1, (char*[]) {
            strdup(".bundle_lock\n"),
        });
        tfree(n);
    }
)

AddrRegDisp = AddrRegReg | AddrRegRegImm | AddrRegImm

AddrRegReg = LP (!AddrReg r1:REG) COMMA (!AddrReg r2:REG) RP {
    $$ = (Transform) { .val = xasprintf("(%s, %s)", r1.val, r2.val) }
}
AddrRegRegImm = LP (!AddrReg r1:REG) COMMA (!AddrReg r2:REG) COMMA i:IMM RP {
    $$ = (Transform) { .val = xasprintf("(%s, %s, %s)", r1.val, r2.val, i.val) }
}
AddrRegImm = LP COMMA (!AddrReg r2:REG) COMMA i:IMM RP {
    $$ = (Transform) { .val = xasprintf("(, %s, %s)", r2.val, i.val) }
}

AddrReg = 'rsp' | 'rip'

AddrNoMod = (
    # imm(...)
      (i:IMM_VAR b:BALANCED) {
        $$ = (Transform) {
            .val = xasprintf("%s%s", i.val, b.val),
        }
    }
    # (...)
    | (b:BALANCED) {
        $$ = (Transform) {
            .val = xasprintf("%s", b.val),
        }
    }
)

BALANCED = < BALANCED_RAW > {
    $$ = (Transform) { .val = strndup(yytext, yyleng) }
}

# --- branches ---

# we use r15 here so that we get consistent instruction sizes, so that the nop
# has the correct size to align the call to the end of the bundle. In theory,
# we could make two CallInds -- one for registers that require a REX prefix and
# one for ones that don't.
CallInd = 'call' 'q'? - '*' r:XREG {
    mkinsn("movq %s, %%r15\n", r.val);
    mkcodedirective(".bundle_lock\n");
    mkinsn("andl $" BUNDLE_MASK ", %%r15d\n");
    mkinsn("orq %%r14, %%r15\n");
    mkinsn("callq *%%r15\n");
    mkcodedirective(".bundle_unlock\n");
    mkcodedirective(".p2align " BUNDLE_P2 "\n");
    tfree(r);
}

CallIndMem = 'call' 'q'? - '*' a:Addr {
    mkguards(a);
    mkinsn("movq %s, %r15\n", a.val);
    mkcodedirective(".bundle_unlock\n");
    mkcodedirective(".bundle_lock\n");
    mkinsn("andl $" BUNDLE_MASK ", %%r15d\n");
    mkinsn("orq %%r14, %%r15\n");
    mkinsn("callq *%%r15\n");
    mkcodedirective(".bundle_unlock\n");
    mkcodedirective(".p2align " BUNDLE_P2 "\n");
    tfree(a);
}

CallIndMemSafe = 'call' 'q'? - '*' a:AddrNoMod {
    mkinsn("movq %s, %r15\n", a.val);
    mkcodedirective(".bundle_lock\n");
    mkinsn("andl $" BUNDLE_MASK ", %%r15d\n");
    mkinsn("orq %%r14, %%r15\n");
    mkinsn("callq *%%r15\n");
    mkcodedirective(".bundle_unlock\n");
    mkcodedirective(".p2align " BUNDLE_P2 "\n");
    tfree(a);
}

Call = 'call' 'q'? - rest:ITEM {
    mkinsn("callq %s\n", rest.val);
    mkcodedirective(".p2align " BUNDLE_P2 "\n");
    tfree(rest);
}

BranchMem = j:JMP - '*' a:Addr {
    mkguards(a);
    mkinsn("movq %s, %%r15\n", a.val);
    mkcodedirective(".bundle_unlock\n");
    mkcodedirective(".bundle_lock\n");
    mkinsn("andl $" BUNDLE_MASK ", %%r15d\n");
    mkinsn("orq %%r14, %%r15\n");
    mkinsn("%s *%%r15\n", j.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(j); tfree(a);
}

BranchMemSafe = j:JMP - '*' a:AddrNoMod {
    mkinsn("movq %s, %%r15\n", a.val);
    mkdirective(".bundle_lock\n");
    mkinsn("andl $" BUNDLE_MASK ", %%r15d\n");
    mkinsn("orq %%r14, %%r15\n");
    mkinsn("%s *%%r15\n", j.val);
    mkcodedirective(".bundle_unlock\n");
    tfree(j); tfree(a);
}

Branch = j:JMP - '*' r:XREG {
    mkdirective(".bundle_lock\n");
    mkinsn("andl $" BUNDLE_MASK ", %s\n", lo(r.val));
    mkinsn("orq %%r14, %s\n", r.val);
    mkinsn("%s *%s\n", j.val, r.val);
    mkdirective(".bundle_unlock\n");
    tfree(j); tfree(r);
}

Leave = 'leave' 'q'? - {
    mkcodedirective(".bundle_lock\n");
    mkinsn("movl %%ebp, %%esp\n");
    mkinsn("orq %%r14, %%rsp\n");
    mkcodedirective(".bundle_unlock\n");
    mkinsn("popq %%rbp\n");
}

JMP = < 'notrack'? - 'jmp' 'q'? > - {
    $$ = (Transform) { .val = strndup(yytext, yyleng) }
}

Ret = 'ret' 'q'? - {
    mkinsn("popq %%r15\n");
    mkdirective(".bundle_lock\n");
    mkinsn("andl $" BUNDLE_MASK ", %%r15d\n");
    mkinsn("orq %%r14, %%r15\n");
    mkinsn("jmpq *%%r15\n");
    mkdirective(".bundle_unlock\n");
}

# --- syscalls ---

Syscall = (( 'syscall' - ) | ( 'int' - '0x80' - )) {
    mkinsn("call *%%gs:0x0\n")
}

# --- reserved register modification ---

ModSP = ModImmSP | ModRegSP

AddrBP = (
    # imm(...)
    (i:IMM_VAR LP r:XREG RP) {
        $$ = (Transform) {
            .val = xasprintf("%s(%s)", i.val, lo(r.val)),
        }
    }
    # (...)
    | (LP r:XREG RP) {
        $$ = (Transform) {
            .val = xasprintf("(%s)", lo(r.val)),
        }
    }
)

ModLeaSP = 'lea' 'q'? - a:AddrBP COMMA '%rsp' - {
    mkcodedirective(".bundle_lock\n");
    mkinsn("leal %s, %%esp\n", a.val);
    mkinsn("orq %%r14, %%rsp\n");
    mkcodedirective(".bundle_unlock\n");
}

ModImmSP = m:MODINST i:IMM COMMA '%rsp' - {
    char* op = l(m.val);
    mkcodedirective(".bundle_lock\n");
    mkinsn("%s %s, %%esp\n", op, i.val);
    mkinsn("orq %%r14, %%rsp\n");
    mkcodedirective(".bundle_unlock\n");
    tfree(m); tfree(i); free(op);
}

ModRegSP = m:MODINST r:XREG COMMA '%rsp' - {
    char* op = l(m.val);
    mkcodedirective(".bundle_lock\n");
    mkinsn("%s %s, %%esp\n", op, lo(r.val));
    mkinsn("orq %%r14, %%rsp\n");
    mkcodedirective(".bundle_unlock\n");
    tfree(m); tfree(r); free(op);
}

MODINST = < (
      ('add' 'q'?)
    | ('sub' 'q'?)
    | ('mov' 'q'?)
    | ('and' 'q'?)
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# --- everything else ---

Any = < (!(EOL | ';') .)* > {
    if (yyleng > 0)
        mkinsn("%s\n", yytext);
}

Label = < ([0-9]+ | ID) > ':' - {
    mklabel(strndup(yytext, yyleng));
}

Directive = < '.' (!EOL .)* > - {
    mkdirective(xasprintf("%s\n", yytext));
}

FnDirective = < '.type' - ([^,])* ',' - '@function' - > {
    mkdirective(xasprintf("%s\n", yytext));
    mkdirective(".p2align " BUNDLE_P2 "\n");
}

NAME = < ('lock' - [\r\n;]? -)? ID > - { $$ = (Transform) { .val = strclean(yytext, yyleng) } }

# --- common definitions ---

IMM = < IMM_RAW > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

IMM_VAR = < ([-+a-zA-Z0-9_.@]+ | BALANCED_RAW) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

NUM = < (('0x' [0-9a-fA-F]+) | [0-9]+) > - {
    $$ = (Transform) { .val = strndup(yytext, yyleng) };
}

IMM_RAW = (
    ('$' -)? 
    (
          [-+0-9abcdefxABCDEF]+
        | BALANCED_RAW
        | RELOC
    )
)

BALANCED_RAW = LP ([^()] | BALANCED_RAW)* RP

RELOC = ':' ID ':' ID

XREG_NOSP = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rbp'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

REG = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rsp'
    | '%rbp'
    | '%r8d'
    | '%r9d'
    | '%r10d'
    | '%r11d'
    | '%r12d'
    | '%r13d'
    | '%r14d'
    | '%r15d'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
    | '%eax'
    | '%ecx'
    | '%edx'
    | '%ebx'
    | '%esi'
    | '%edi'
    | '%esp'
    | '%ebp'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

HREG = < '%' [abcd] 'h' > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

XREG = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rsp'
    | '%rbp'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

ID = [a-zA-Z_.][-a-zA-Z0-9_.+]*

ITEM = < [^ ,;\n\r#/]+ > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

COMMA   = ',' -
EXCLAM  = '!' -
LB      = '[' -
RB      = ']' -
LP      = '(' -
RP      = ')' -
LC      = '{' -
RC      = '}' -
-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r'

%%

enum {
    FIXUP_DIST = 8000,
};

static int
dist(int a, int b)
{
    int d = a - b;
    if (d < 0)
        d = -d;
    return d;
}

static size_t
min(size_t a, size_t b)
{
    if (a < b)
        return a;
    return b;
}

static size_t
max(size_t a, size_t b)
{
    if (a > b)
        return a;
    return b;
}

size_t x64_insn_size(char*);

bool
lfigen()
{
    // while (yyparse());
    if (!yyparse())
        return false;

    fprintf(output, ".bundle_align_mode " BUNDLE_P2 "\n");
    struct op* op = ops;
    while (op) {
        if (op->label && op->next && (op->next->insn || op->next->code))
            fprintf(output, ".p2align " BUNDLE_P2 "\n");
        fprintf(output, "%s", op->text);
        op = op->next;
    }

    return true;
}
